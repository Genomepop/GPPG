/*
 *  Operation.h
 *  GPPG
 *
 *  Created by Troy Ruths on 5/11/12.
 *  Copyright 2012 Rice University. All rights reserved.
 *
 */

#ifndef CORE_OPERATION_
#define CORE_OPERATION_


#include "Genotype.h"
#include <list>


namespace GPPG {
	
	/** IOperation adds additional functions to the IGenotype interface.  In doing so,
	 * Genotypes may be represented as a cascade of Operations, which is much more memory efficient.
	 */
	class IOperation  {
	public:
		virtual ~IOperation() {}
		
		/** Retrieves the Genotype generated by this operation.
		 *
		 */
		//virtual IGenotypeOp& genotype() const;
		
		/** Set this Operation to be compressed or uncompressed.
		 * Uncompressing occurs during this function call --- so don't use it unless you have to!
		 */
		virtual void setCompressed(bool compress) = 0;
		virtual bool isCompressed() const = 0;
		
		// Should this be a part of the interface?
		virtual void setLoad(double value) = 0;
		virtual double load() const = 0;
		
		/** Returns whether or not the genotype of this operation is active
		 * 
		 */
		//virtual bool isActive() const = 0;
		
		/** Returns the cost of applying this operation.
		 * The cost is provided in the construction of the operation and should take into account
		 * the complexity of the operation and the amount of CPU-time required to apply it.
		 */
		virtual double cost() const = 0;
		
		/** Returns the data footprint of this operation (plus cache)
		 *
		 */
		virtual int dataSize() const = 0;
		
		/** Returns the number of child operations.
		 * The children of an Operation are implicitly acquired which a subsequent Operation object uses this Operation as its parent.
		 */ 
		virtual int numChildren() const = 0;
		
		/** Retrieves the first or second parent.
		 *  @param i - the parent to retrieve (0 or 1)
		 */ 
		virtual IOperation* parent(int i) = 0;
		
		/** The number of parents for this operation.
		 */
		virtual int numParents() const = 0;
		
	};
	
	
	template <typename T> class Operation : public Genotype<T>, public IOperation {
			
	public:
		Operation<T>(double cost): Genotype<T>(0) { innerConstructor(cost, 0, 0); }
		Operation<T>(double cost, Operation<T> &parent) : Genotype<T>(0) { innerConstructor(cost, &parent, 0); }
		Operation<T>(double cost, Operation<T> &parent1, Operation<T> &parent2): Genotype<T>(0) { innerConstructor(cost, &parent1, &parent2); }
		
		~Operation<T>() {}
		
		
		Operation<T> const* parent(int i) const {
			if( i<0 || i>=numParents()) { throw "Incorrect index"; }
			
			switch( i ){
				case 0: return _parent1; 
				case 1: return _parent2;
			}
			
			throw "Index is too high";
		}
		
		Operation<T>* parent(int i) {
			if( i<0 || i>=numParents()) { throw "Incorrect index"; }
			
			switch( i ){
				case 0: return _parent1; 
				case 1: return _parent2;
			}
			
			throw "Index is too high";
		}
		
		int numParents() const {
			if (_parent2 != 0) {
				return 2;
			} else if (_parent1 != 0) {
				return 1;
			}
			return 0;
		}
		
		/** Returns a pointer to the data produced by this Operation.
		 * Returns the result of this operation. If the cache is full, then it will be returned quickly; 
		 * otherwise, the operation will be evaluated, along with its parents.
		 */
		/* NOTE: I commented this out b/c it is inconsistent.
		T* data() const {
			if (isCompressed()) {
				return ;
			}
			return Genotype<T>::data();
		}
		*/
		
		/**
		 Returns the number of children
		 */
		int numChildren() const {
			return _children.size();
		}
		
		//set<Operation<T>& >& children() const;
		
		// Manage compression
		void setCompressed(bool compress) {
			if (compress && !isCompressed()) {
				Genotype<T>::setData(0);
			} else if (!compress && isCompressed()) {
				// Fill the cache
				Genotype<T>::setData( evaluate() );
			}
		}
		
		/** Returns the data cache.
		 * It may return a NULL pointer.
		 */
		T* data() const { return Genotype<T>::data(); }
		
		bool isCompressed() const { return data() == NULL; }
		
		// Manage Load
		void setLoad(double value) { _load = value; }
		double load() const { return _load; }
		
		// Data Size
		int dataSize() const { return 1; }
		
		/**
		 * The cost of applying the operation
		 */
		double cost() const { return _cost; }

		/** Returns a no-strings attached evaluation of this Operation.
		 * Consuming code must delete the result when finished with it.
		 */
		T* evaluate() const {
			if (isCompressed()) {
				return NULL;
			}
			return Genotype<T>::data()->copy();	
		}
	
		
	private:
		Operation<T>(Operation<T> const& op) {}
		Operation<T>& operator=(Operation<T> const& op) {}
		
		void inline innerConstructor(double cost, Operation<T>* parent1, Operation<T>* parent2) {
			_cost = cost;
			_parent1 = parent1;
			_parent2 = parent2;
			
			if (_parent1 != 0) {
				_parent1->addChild( this );
			}
			if (_parent2 != 0) {
				_parent2->addChild( this );
			}
			
			_load = 0;
		}
		
		void addChild(Operation<T>* op) {
			_children.push_back(op);
		}
		
		void removeChild(Operation<T>* op) {
			_children.remove( op );
		}
		
		std::list< Operation<T> *> _children;
		
		
		double _load;
		double _cost;
		Operation<T> *_parent1, *_parent2;
		
		
	};
}

#endif
