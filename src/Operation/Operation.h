/*
 *  Operation.h
 *  GPPG
 *
 *  Created by Troy Ruths on 5/11/12.
 *  Copyright 2012 Rice University. All rights reserved.
 *
 */

#ifndef CORE_OPERATION_
#define CORE_OPERATION_


#include "Genotype.h"
#include <list>


namespace GPPG {
	
	/** IOperation adds additional functions to the IGenotype interface.  In doing so,
	 * Genotypes may be represented as a cascade of Operations, which is much more memory efficient.
	 */
	class IOperation : public IGenotype {
	public:
		virtual ~IOperation(){}
		
		/** Retrieves the Genotype generated by this operation.
		 *
		 */
		//virtual IGenotypeOp& genotype() const;
		
		/** Set this Operation to be compressed or uncompressed.
		 * Uncompressing occurs during this function call --- so don't use it unless you have to!
		 */
		virtual void setCompressed(bool compress) = 0;
		virtual bool isCompressed() = 0;
		
		// Should this be a part of the interface?
		virtual void setLoad(double value) = 0;
		virtual double load() const = 0;
		
		/** Returns whether or not the genotype of this operation is active
		 * 
		 */
		//virtual bool isActive() const = 0;
		
		/** Returns the cost of applying this operation.
		 * The cost is provided in the construction of the operation and should take into account
		 * the complexity of the operation and the amount of CPU-time required to apply it.
		 */
		virtual double cost() const = 0;
		
		/** Returns the data footprint of this operation (plus cache)
		 *
		 */
		virtual int dataSize() const = 0;
		
		/** Returns the number of child operations.
		 * The children of an Operation are implicitly acquired which a subsequent Operation object uses this Operation as its parent.
		 */ 
		virtual int numChildren() const = 0;
		
		/** Retrieves the first or second parent.
		 *  @param i - the parent to retrieve (0 or 1)
		 */ 
		virtual IOperation& parent(int i) = 0;
		
		/** The number of parents for this operation.
		 */
		virtual int numParents() const = 0;
		
	};
	
	template <typename T> class Operation : public Genotype<T>, public IOperation {
	public:
		Operation<T>(double cost);
		Operation<T>(double cost, Operation<T> &parent);
		Operation<T>(double cost, Operation<T> &parent1, Operation<T> &parent2);
		
		~Operation<T>();
		
		//GenotypeOp<T>& genotype() const;
		
		Operation<T>& parent(int i) const;
		int numParents() const;
		
		/**
		 Returns the result of this operation. If the cache is full, then it will be returned quickly; 
		 otherwise, the operation will be evaluated, along with its parents.
		 */
		virtual T* data() const;
		
		/**
		 Returns the number of children
		 */
		int numChildren() const;
		//set<Operation<T>& >& children() const;
		
		// Manage compression
		void setCompressed(bool compress);
		bool isCompressed() const;
		
		// Manage Load
		void setLoad(double value);
		double load() const;
		
		// Data Size
		int dataSize() const;
		
		/**
		 * The cost of applying the operation
		 */
		double cost() const;
		
	protected:
		virtual T* evaluate() const;
		
		
	private:
		
		Operation<T>(Operation<T> const& op) {}
		Operation<T>& operator=(Operation<T> const& op) {}
		
		void inline innerConstructor(double cost, Operation<T>* parent1, Operation<T>* parent2);
		void addChild(Operation<T>* op);
		void removeChild(Operation<T>* op);
		
		std::list< Operation<T> *> _children;
		
		
		double _load;
		double _cost;
		Operation<T> *_parent1, *_parent2;
		
	};
}

#endif
